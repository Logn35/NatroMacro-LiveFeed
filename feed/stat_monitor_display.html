<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stat Monitor</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 20px;
            background-color: #121212;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .content-row {
            display: flex;
            gap: 16px;
            flex: 1 1 auto;
            min-height: 0;
            align-items: stretch;
            padding: 0 20px;
        }

        /* Messages container */
        #messages-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 300px;
            overflow: hidden;
            flex-grow: 1;
            padding: 0 10px;
        }
        .feed-box {
            background: #201E20;
            border-radius: 8px;
            border: 1px solid #2C2A2C;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.25);
            padding: 10px 12px;
            margin: 0;
            max-width: 300px;
            flex: 0 0 300px;
            overflow: hidden;
        }
        .chart-box {
            background: #201E20;
            border-radius: 10px;
            border: 1px solid #2C2A2C;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.25);
            padding: 14px 16px;
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }
        .chart-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 6px;
            position: relative;
        }
        .chart-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }
        .chart-divider {
            height: 1px;
            background: #2C2A2C;
            margin: 4px 0 8px;
            width: 100%;
        }
        .chart-divider.spaced {
            margin-bottom: 16px;
        }
        .chart-subtitle {
            font-size: 10px;
            color: #8a8a8a;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 8px;
            text-align: center;
        }
        .chart-box.compact-subtitles .chart-subtitle {
            display: none;
        }
        .chart-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex: 1 1 auto;
            justify-content: flex-end;
            margin-top: -6px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 160px;
        }
        .control-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #888;
            flex: 0 0 auto;
        }
        .control-icon svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 1.8;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .control-icon .fill {
            fill: currentColor;
            stroke: none;
        }
        .control-wrap {
            position: relative;
            flex: 1 1 auto;
            height: 28px;
        }
        .control-ticks {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        .control-ticks span {
            width: 2px;
            height: 100%;
            background: rgba(192, 192, 240, 0.35);
            border-radius: 2px;
            transform: scaleY(0.45);
            transform-origin: center;
        }
        .control-ticks span.mid {
            background: rgba(192, 192, 240, 0.4);
            transform: scaleY(0.45);
        }
        .control-input {
            appearance: none;
            width: 100%;
            height: 28px;
            background: transparent;
            margin: 0;
            cursor: pointer;
        }
        .control-input::-webkit-slider-runnable-track {
            height: 6px;
            background: #2C2A2C;
            border-radius: 999px;
        }
        .control-input::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #d6d6de;
            border: 2px solid #1e1d1f;
            margin-top: -4px;
        }
        .control-input::-moz-range-track {
            height: 6px;
            background: #2C2A2C;
            border-radius: 999px;
        }
        .control-input::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #d6d6de;
            border: 2px solid #1e1d1f;
        }
        .chart-canvas-wrap {
            position: relative;
            flex: 1 1 0;
            min-height: 70px;
            max-height: 220px;
            background: #201E20;
            border-radius: 8px;
            overflow: hidden;
        }
        .chart-canvas-wrap-large {
            flex-grow: 4.5;
            min-height: 280px;
            max-height: 680px;
        }
        .chart-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
            touch-action: none;
        }
        .feed-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-align: center;
        }

        .message {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            gap: 0;
            width: 100%;
        }
        .color-bar {
            width: 4px;
            border-radius: 4px 0 0 4px;
            flex-shrink: 0;
        }
        .embed {
            background-color: #272527;
            border-radius: 0 6px 6px 0;
            padding: 8px 10px;
            flex: 1 1 auto;
        }
        .message {
            border-radius: 6px;
            overflow: hidden;
        }
        .embed-content {
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .no-messages {
            color: #555;
            font-style: italic;
            padding: 20px;
        }
        .bold {
            font-weight: 700;
            color: #fff;
        }
        code {
            background: #2C2A2C;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* Stats Header */
        .stats-header {
            display: flex;
            justify-content: center;
            column-gap: 16px;
            row-gap: 12px;
            padding: 8px 20px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: stretch;
        }
        .stats-header.force-second-row {
            row-gap: 4px;
        }
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 140px;
            padding: 3px 10px 6px 10px;
            background: #201E20;
            border-radius: 8px;
            border: 1px solid #2C2A2C;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            height: 78px;
        }
        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            background: #2C2A2C;
            border-radius: 4px;
            line-height: 1;
        }
        .stat-rate {
            font-size: 11px;
            color: #9aa0a6;
            margin-top: 3px;
            text-align: center;
            min-height: 12px;
        }
        .stat-text {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transform: translateY(-2px);
        }
        .stat-value.honey {
            color: #ffc107;
        }
        .stat-value.backpack {
            position: relative;
            text-align: center;
            color: #f8f8f8;
            overflow: hidden;
        }
        .backpack-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            border-radius: 4px;
            z-index: 0;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        .backpack-text {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-2px);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
        }
        .planters-box {
            width: 420px;
            flex: 0 0 420px;
            align-items: stretch;
            order: 3;
        }
        .planters-box .stat-label {
            width: 100%;
            text-align: center;
        }
        .nectars-box {
            width: 320px;
            flex: 0 0 320px;
            order: 3;
        }
        .buffs-box {
            width: auto;
            flex: 2 1 0;
            justify-content: flex-start;
            order: 2;
        }
        .stats-header.force-second-row .planters-box {
            flex: 1 1 0;
            width: auto;
            min-width: 420px;
            margin-top: 12px;
        }
        .stats-header.force-second-row .nectars-box {
            margin-top: 12px;
        }
        .flex-break {
            flex-basis: 100%;
            height: 0;
            display: none;
            order: 3;
        }
        .stats-header.force-second-row .flex-break {
            display: block;
        }
        .buffs-header {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }
        .buffs-filter {
            position: absolute;
            right: 0;
            top: 0;
        }
        .buffs-filter-btn {
            background: #2C2A2C;
            color: #d4d4d4;
            font-size: 0;
            padding: 4px;
            border-radius: 6px;
            cursor: pointer;
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: none;
        }
        .buffs-filter-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        .buffs-filter-panel {
            position: absolute;
            right: 0;
            top: calc(100% + 6px);
            background: #1b1a1b;
            border: 1px solid #2C2A2C;
            border-radius: 8px;
            padding: 8px 10px;
            min-width: 160px;
            max-height: 220px;
            overflow: auto;
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3);
            z-index: 5;
            display: none;
        }
        .buffs-filter-panel.open {
            display: block;
        }
        .buffs-filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #cfcfcf;
            padding: 4px 0;
            cursor: pointer;
        }
        .buffs-filter-item input {
            width: 14px;
            height: 14px;
        }
        .buff-hidden {
            display: none;
        }
        .buffs-box .buffs-grid {
            flex: 1;
            align-content: center;
        }
        .buffs-grid {
            --buff-gap: 2px;
            --buff-count: 18;
            --buff-size: clamp(20px, calc((100% - (var(--buff-gap) * (var(--buff-count) - 1))) / var(--buff-count)), 44px);
            display: flex;
            gap: var(--buff-gap);
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow: hidden;
        }
        .buff-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .buff-item.buff-hidden {
            display: none;
        }
        .buff-icon-wrap {
            position: relative;
            width: var(--buff-size);
            height: var(--buff-size);
            --buff-icon: none;
            --buff-fill: 0%;
        }
        .buff-icon-wrap::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 4px;
            background-image: var(--buff-icon);
            background-size: cover;
            background-position: center;
            clip-path: inset(calc(100% - var(--buff-fill)) 0 0 0);
            transition: clip-path 0.25s ease;
        }
        .buff-icon-img {
            width: var(--buff-size);
            height: var(--buff-size);
            border-radius: 4px;
            background: #2f2f2f;
            object-fit: cover;
            opacity: 0.25;
        }
        .buff-stack {
            position: absolute;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            color: #f5f5f5;
            font-size: 11px;
            font-weight: 700;
            padding: 1px 4px;
            border-radius: 4px;
            line-height: 1;
            z-index: 2;
            display: block;
        }
        .nectars-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            width: 100%;
            flex: 1;
        }
        .nectar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 54px;
        }
        .nectar-ring-wrap {
            position: relative;
            width: 34px;
            height: 34px;
        }
        .nectar-ring {
            width: 34px;
            height: 34px;
            transform: rotate(-90deg);
        }
        .nectar-ring circle {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
        }
        .nectar-ring .ring-bg {
            stroke: #2f2f2f;
        }
        .nectar-ring .ring-value {
            stroke-linecap: butt;
        }
        .nectar-ring .ring-projected {
            opacity: 0.5;
            stroke-dasharray: 2 4;
            stroke-linecap: butt;
            stroke: none;
        }
        .nectar-icon-center {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .nectar-icon-center img {
            width: 17px;
            height: 17px;
            object-fit: contain;
        }
        .nectar-percent {
            font-size: 10px;
            color: #cfcfcf;
            line-height: 1;
        }
        .nectar-percent-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .nectar-plus {
            font-size: 9px;
            color: #9b9b9b;
            line-height: 1;
        }
        .nectar-bar {
            width: 50px;
            height: 6px;
            border-radius: 999px;
            background: #2f2f2f;
            position: relative;
            overflow: hidden;
        }
        .nectar-fill {
            height: 100%;
            border-radius: inherit;
            width: 0%;
        }
        .nectar-projected {
            position: absolute;
            top: 0;
            height: 100%;
            border-radius: 0 999px 999px 0;
            width: 0%;
            opacity: 0.5;
        }
        .planters-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
            width: 100%;
            flex: 1;
        }
        .planter-slot {
            background: #2C2A2C;
            border-radius: 6px;
            padding: 4px 6px;
            min-height: 32px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 6px;
        }
        .planter-slot.empty {
            color: #666;
        }
        .planter-icons {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
        }
        .planter-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            min-width: 0;
        }
        .planter-icon {
            width: 28px;
            height: 28px;
            object-fit: contain;
            display: none;
        }
        .planter-field {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: #b2b2b2;
            justify-content: flex-start;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .nectar-inline {
            width: 14px;
            height: 14px;
            object-fit: contain;
            display: none;
        }
        .timer-icon {
            width: 12px;
            height: 12px;
            display: inline-block;
            flex-shrink: 0;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='5' fill='none' stroke='%238a8a8a' stroke-width='1'/%3E%3Cpath d='M6 3.2v3l2.2 1.2' fill='none' stroke='%238a8a8a' stroke-width='1' stroke-linecap='round'/%3E%3C/svg%3E") no-repeat center / contain;
        }
        .planter-timer {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            font-weight: 700;
            color: #f8f8f8;
            justify-content: flex-start;
        }
    </style>
</head>
<body>
    <div class="stats-header">
        <div class="stat-box">
            <div class="stat-label">Honey</div>
            <div class="stat-value honey">
                <span class="stat-text" id="honey-value">--</span>
            </div>
            <div class="stat-rate" id="honey-rate">+0/sec</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Pollen</div>
            <div class="stat-value backpack" id="backpack-value">
                <div class="backpack-bar" id="backpack-bar" style="width: 0%"></div>
                <span class="backpack-text" id="backpack-text">--%</span>
            </div>
            <div class="stat-rate" id="backpack-rate">+0/sec</div>
        </div>
        <div class="stat-box buffs-box">
            <div class="buffs-header">
                <div class="stat-label">Buffs</div>
                <div class="buffs-filter">
                    <button class="buffs-filter-btn" id="buff-filter-btn" type="button" aria-label="Filter buffs">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 .8 1.6l-6.8 9.07V20a1 1 0 0 1-1.45.9l-3-1.5A1 1 0 0 1 9 18.5v-3.83L3.2 6.6A1 1 0 0 1 3 5z"/>
                        </svg>
                    </button>
                    <div class="buffs-filter-panel" id="buff-filter-panel"></div>
                </div>
            </div>
            <div class="buffs-grid">
                <div class="buff-item" data-buff="blueboost">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-blueboost" alt="">
                        <div class="buff-stack" id="buff-val-blueboost">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="redboost">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-redboost" alt="">
                        <div class="buff-stack" id="buff-val-redboost">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="whiteboost">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-whiteboost" alt="">
                        <div class="buff-stack" id="buff-val-whiteboost">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="haste">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-haste" alt="">
                        <div class="buff-stack" id="buff-val-haste">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="focus">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-focus" alt="">
                        <div class="buff-stack" id="buff-val-focus">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="bombcombo">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-bombcombo" alt="">
                        <div class="buff-stack" id="buff-val-bombcombo">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="balloonaura">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-balloonaura" alt="">
                        <div class="buff-stack" id="buff-val-balloonaura">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="inspire">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-inspire" alt="">
                        <div class="buff-stack" id="buff-val-inspire">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="reindeerfetch">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-reindeerfetch" alt="">
                        <div class="buff-stack" id="buff-val-reindeerfetch">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="honeymark">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-honeymark" alt="">
                        <div class="buff-stack" id="buff-val-honeymark">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="pollenmark">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-pollenmark" alt="">
                        <div class="buff-stack" id="buff-val-pollenmark">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="festivemark">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-festivemark" alt="">
                        <div class="buff-stack" id="buff-val-festivemark"></div>
                    </div>
                </div>
                <div class="buff-item" data-buff="popstar">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-popstar" alt="">
                        <div class="buff-stack" id="buff-val-popstar">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="melody">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-melody" alt="">
                        <div class="buff-stack" id="buff-val-melody">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="bear">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-bear" alt="">
                        <div class="buff-stack" id="buff-val-bear">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="babylove">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-babylove" alt="">
                        <div class="buff-stack" id="buff-val-babylove">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="jbshare">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-jbshare" alt="">
                        <div class="buff-stack" id="buff-val-jbshare">x0</div>
                    </div>
                </div>
                <div class="buff-item" data-buff="guiding">
                    <div class="buff-icon-wrap">
                        <img class="buff-icon-img" id="buff-icon-guiding" alt="">
                        <div class="buff-stack" id="buff-val-guiding">x0</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="flex-break" aria-hidden="true"></div>
        <div class="stat-box planters-box">
            <div class="stat-label">Planters</div>
            <div class="planters-grid">
                <div class="planter-slot empty" id="planter-slot-1">
                    <div class="planter-icons">
                        <img class="planter-icon" id="planter-icon-1" alt="">
                    </div>
                    <div class="planter-info">
                        <div class="planter-field">
                            <img class="nectar-inline" id="nectar-inline-1" alt="">
                            <span id="planter-field-1">Empty</span>
                        </div>
                        <div class="planter-timer">
                            <span class="timer-icon" aria-hidden="true"></span>
                            <span id="planter-timer-1">--</span>
                        </div>
                    </div>
                </div>
                <div class="planter-slot empty" id="planter-slot-2">
                    <div class="planter-icons">
                        <img class="planter-icon" id="planter-icon-2" alt="">
                    </div>
                    <div class="planter-info">
                        <div class="planter-field">
                            <img class="nectar-inline" id="nectar-inline-2" alt="">
                            <span id="planter-field-2">Empty</span>
                        </div>
                        <div class="planter-timer">
                            <span class="timer-icon" aria-hidden="true"></span>
                            <span id="planter-timer-2">--</span>
                        </div>
                    </div>
                </div>
                <div class="planter-slot empty" id="planter-slot-3">
                    <div class="planter-icons">
                        <img class="planter-icon" id="planter-icon-3" alt="">
                    </div>
                    <div class="planter-info">
                        <div class="planter-field">
                            <img class="nectar-inline" id="nectar-inline-3" alt="">
                            <span id="planter-field-3">Empty</span>
                        </div>
                        <div class="planter-timer">
                            <span class="timer-icon" aria-hidden="true"></span>
                            <span id="planter-timer-3">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="stat-box nectars-box">
            <div class="stat-label">Nectars</div>
            <div class="nectars-row">
                <div class="nectar-item" data-nectar="comforting">
                    <div class="nectar-ring-wrap">
                        <svg class="nectar-ring" viewBox="0 0 36 36">
                            <circle class="ring-bg" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-value" id="nectar-ring-comforting" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-projected" id="nectar-proj-comforting" cx="18" cy="18" r="15"></circle>
                        </svg>
                        <div class="nectar-icon-center">
                            <img src="../nm_image_assets/ptimers/nectars/comforting.png" alt="">
                        </div>
                    </div>
                    <div class="nectar-percent-row">
                        <div class="nectar-percent" id="nectar-val-comforting">0%</div>
                        <div class="nectar-plus" id="nectar-plus-comforting"></div>
                    </div>
                </div>
                <div class="nectar-item" data-nectar="motivating">
                    <div class="nectar-ring-wrap">
                        <svg class="nectar-ring" viewBox="0 0 36 36">
                            <circle class="ring-bg" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-value" id="nectar-ring-motivating" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-projected" id="nectar-proj-motivating" cx="18" cy="18" r="15"></circle>
                        </svg>
                        <div class="nectar-icon-center">
                            <img src="../nm_image_assets/ptimers/nectars/motivating.png" alt="">
                        </div>
                    </div>
                    <div class="nectar-percent-row">
                        <div class="nectar-percent" id="nectar-val-motivating">0%</div>
                        <div class="nectar-plus" id="nectar-plus-motivating"></div>
                    </div>
                </div>
                <div class="nectar-item" data-nectar="satisfying">
                    <div class="nectar-ring-wrap">
                        <svg class="nectar-ring" viewBox="0 0 36 36">
                            <circle class="ring-bg" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-value" id="nectar-ring-satisfying" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-projected" id="nectar-proj-satisfying" cx="18" cy="18" r="15"></circle>
                        </svg>
                        <div class="nectar-icon-center">
                            <img src="../nm_image_assets/ptimers/nectars/satisfying.png" alt="">
                        </div>
                    </div>
                    <div class="nectar-percent-row">
                        <div class="nectar-percent" id="nectar-val-satisfying">0%</div>
                        <div class="nectar-plus" id="nectar-plus-satisfying"></div>
                    </div>
                </div>
                <div class="nectar-item" data-nectar="refreshing">
                    <div class="nectar-ring-wrap">
                        <svg class="nectar-ring" viewBox="0 0 36 36">
                            <circle class="ring-bg" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-value" id="nectar-ring-refreshing" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-projected" id="nectar-proj-refreshing" cx="18" cy="18" r="15"></circle>
                        </svg>
                        <div class="nectar-icon-center">
                            <img src="../nm_image_assets/ptimers/nectars/refreshing.png" alt="">
                        </div>
                    </div>
                    <div class="nectar-percent-row">
                        <div class="nectar-percent" id="nectar-val-refreshing">0%</div>
                        <div class="nectar-plus" id="nectar-plus-refreshing"></div>
                    </div>
                </div>
                <div class="nectar-item" data-nectar="invigorating">
                    <div class="nectar-ring-wrap">
                        <svg class="nectar-ring" viewBox="0 0 36 36">
                            <circle class="ring-bg" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-value" id="nectar-ring-invigorating" cx="18" cy="18" r="15"></circle>
                            <circle class="ring-projected" id="nectar-proj-invigorating" cx="18" cy="18" r="15"></circle>
                        </svg>
                        <div class="nectar-icon-center">
                            <img src="../nm_image_assets/ptimers/nectars/invigorating.png" alt="">
                        </div>
                    </div>
                    <div class="nectar-percent-row">
                        <div class="nectar-percent" id="nectar-val-invigorating">0%</div>
                        <div class="nectar-plus" id="nectar-plus-invigorating"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="content-row">
        <div class="feed-box">
            <div class="feed-title">Status</div>
            <div id="messages-container">
                <div class="no-messages">Waiting for messages...</div>
            </div>
        </div>
        <div class="chart-box">
            <div class="chart-subtitle">Honey / Sec</div>
            <div class="chart-canvas-wrap">
                <canvas class="chart-canvas" id="honey-chart"></canvas>
            </div>
            <div class="chart-subtitle">Pollen</div>
            <div class="chart-canvas-wrap">
                <canvas class="chart-canvas" id="pollen-chart"></canvas>
            </div>
            <div class="chart-subtitle">Buff Uptime</div>
            <div class="chart-canvas-wrap chart-canvas-wrap-large">
                <canvas class="chart-canvas" id="buff-uptime-chart"></canvas>
            </div>
        </div>
    </div>

    <script src="buff_icons.js"></script>
    <script>
        function colorToHex(color) {
            if (typeof color === 'string') color = parseInt(color);
            if (!color || isNaN(color)) return '#666';
            return '#' + color.toString(16).padStart(6, '0');
        }

        function formatMessage(text) {
            if (!text) return '';
            text = text.replace(/\*\*(.+?)\*\*/g, '<span class="bold">$1</span>');
            text = text.replace(/\\n/g, '<br>');
            text = text.replace(/\n/g, '<br>');
            text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
            return text;
        }

        function displayMessages() {
            const container = document.getElementById('messages-container');

            if (typeof statMessages === 'undefined' || !statMessages || statMessages.length === 0) {
                container.innerHTML = '<div class="no-messages">Waiting for messages...</div>';
                return;
            }

            let html = '';
            for (let i = statMessages.length - 1; i >= 0; i--) {
                const msg = statMessages[i];
                const color = colorToHex(msg.color);
                html += `
                    <div class="message">
                        <div class="color-bar" style="background-color: ${color};"></div>
                        <div class="embed">
                            <div class="embed-content">${formatMessage(msg.message || '')}</div>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
            updateActivityTimeline();
        }

        function reloadMessages() {
            const oldScript = document.getElementById('messages-script');
            if (oldScript) oldScript.remove();

            const script = document.createElement('script');
            script.id = 'messages-script';
            script.src = 'stat_monitor_messages.js?t=' + Date.now();
            script.onload = displayMessages;
            script.onerror = function() {};
            document.head.appendChild(script);
        }

        function formatHoney(value) {
            if (value === null || value === undefined || value === '--') return '--';
            const num = Number(value);
            if (isNaN(num)) return value;
            if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Q';
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toLocaleString();
        }

        function formatRate(value) {
            if (value === null || value === undefined) return '+0/sec';
            const num = Number(value);
            if (isNaN(num)) return `+${value}/sec`;
            return `+${formatHoney(num)}/sec`;
        }
        function parseRgb(color) {
            const match = String(color).match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/i);
            if (!match) return null;
            return {
                r: Number(match[1]),
                g: Number(match[2]),
                b: Number(match[3])
            };
        }

        // Calculate color from green to yellow to red based on percentage
        function getBackpackColor(percent) {
            // 0% = green (76, 175, 80), 50% = yellow (255, 235, 59), 100% = red (244, 67, 54)
            let r, g, b;
            if (percent <= 50) {
                // Green to Yellow
                const t = percent / 50;
                r = Math.round(76 + (255 - 76) * t);
                g = Math.round(175 + (235 - 175) * t);
                b = Math.round(80 + (59 - 80) * t);
            } else {
                // Yellow to Red
                const t = (percent - 50) / 50;
                r = Math.round(255 + (244 - 255) * t);
                g = Math.round(235 + (67 - 235) * t);
                b = Math.round(59 + (54 - 59) * t);
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        function activityFromMessage(msg) {
            if (!msg) return 'other';
            const color = Number(msg.color);
            if (color === 9755247) return 'gather';
            if (color === 8871681) return 'convert';
            const text = String(msg.message || '').toLowerCase();
            if (text.includes('gather')) return 'gather';
            if (text.includes('convert')) return 'convert';
            return 'other';
        }

        function getActivityColor(activity) {
            if (activity === 'gather') return '#a6ff7c';
            if (activity === 'convert') return '#feca40';
            return '#859aad';
        }

        function getBuffIconImage(name) {
            if (buffIconImages.has(name)) return buffIconImages.get(name);
            if (!window.BUFF_ICON_SOURCES || !window.BUFF_ICON_SOURCES[name]) return null;
            const img = new Image();
            img.src = window.BUFF_ICON_SOURCES[name];
            buffIconImages.set(name, img);
            return img;
        }

        function scheduleChartRender() {
            if (chartRenderQueued) return;
            chartRenderQueued = true;
            requestAnimationFrame(() => {
                chartRenderQueued = false;
                drawHoneyChart();
                drawPollenChart();
                drawBuffUptimeChart();
            });
        }

        function updateActivityTimeline() {
            if (typeof statMessages === 'undefined' || !Array.isArray(statMessages)) return;
            const timeline = [];
            for (const msg of statMessages) {
                if (!msg || !msg.timestamp) continue;
                const ts = Date.parse(String(msg.timestamp).replace(' ', 'T'));
                if (isNaN(ts)) continue;
                timeline.push({ t: ts, activity: activityFromMessage(msg) });
            }
            timeline.sort((a, b) => a.t - b.t);
            honeyActivityTimeline = timeline;
            currentActivity = timeline.length ? timeline[timeline.length - 1].activity : currentActivity;
            applyActivityToHoneySeries();
        }

        function getActivityAt(timeMs) {
            if (!honeyActivityTimeline.length) return currentActivity;
            for (let i = honeyActivityTimeline.length - 1; i >= 0; i--) {
                if (honeyActivityTimeline[i].t <= timeMs) return honeyActivityTimeline[i].activity;
            }
            return honeyActivityTimeline[0].activity;
        }

        function applyActivityToHoneySeries() {
            if (!honeySeries.length) return;
            for (const point of honeySeries) {
                point.activity = getActivityAt(point.t);
            }
            drawHoneyChart();
        }

        function normalizeKey(value) {
            return String(value || '').toLowerCase().replace(/\s+/g, '');
        }

        function getPlanterImage(name) {
            if (!name || name === 'None') return '';
            return `../nm_image_assets/ptimers/planters/${normalizeKey(name)}.png`;
        }

        function getNectarImage(name) {
            if (!name || name === 'None') return '';
            return `../nm_image_assets/ptimers/nectars/${normalizeKey(name)}.png`;
        }

        function formatTimer(totalSeconds) {
            const seconds = Math.max(0, Math.floor(totalSeconds));
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) {
                return `${hrs}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
            return `${mins}:${String(secs).padStart(2, '0')}`;
        }

        function setRingProgress(circle, percent, offsetPercent = 0) {
            const radius = 15;
            const circumference = 2 * Math.PI * radius;
            const clamped = Math.max(0, Math.min(100, percent));
            const dash = (clamped / 100) * circumference;
            circle.style.strokeDasharray = `${dash} ${circumference - dash}`;
            circle.style.strokeDashoffset = circumference * (1 - offsetPercent / 100);
        }

        function updateNectars(nectars) {
            const colors = {
                comforting: '#7e9eb3',
                motivating: '#937db3',
                satisfying: '#b398a7',
                refreshing: '#78b375',
                invigorating: '#b35951'
            };

            if (!Array.isArray(nectars)) return;
            for (const nectar of nectars) {
                const name = nectar.name || '';
                const value = Number(nectar.value || 0);
                const projected = Number(nectar.projected || 0);
                const ring = document.getElementById(`nectar-ring-${name}`);
                const proj = document.getElementById(`nectar-proj-${name}`);
                const val = document.getElementById(`nectar-val-${name}`);
                const plus = document.getElementById(`nectar-plus-${name}`);
                if (!ring || !proj || !val || !plus) continue;

                const color = colors[name] || '#888';
                ring.style.stroke = value > 0 ? color : 'none';
                proj.style.stroke = color;
                setRingProgress(ring, value, 0);
                if (projected > 0) {
                    setRingProgress(proj, projected, value);
                    proj.style.opacity = '0.6';
                    proj.style.stroke = color;
                    plus.textContent = `+${Math.round(projected)}%`;
                } else {
                    setRingProgress(proj, 0, 0);
                    proj.style.opacity = '0';
                    proj.style.strokeDasharray = '0 999';
                    proj.style.stroke = 'none';
                    plus.textContent = '';
                }
                val.style.color = color;
                plus.style.color = color;
                val.textContent = `${Math.round(value)}%`;
            }
        }

        let lastBuffs = null;
        let buffFilterReady = false;
        let buffFilterHidden = new Set();
        const buffFilterOrder = [
            'blueboost',
            'redboost',
            'whiteboost',
            'haste',
            'focus',
            'bombcombo',
            'balloonaura',
            'inspire',
            'reindeerfetch',
            'honeymark',
            'pollenmark',
            'festivemark',
            'popstar',
            'melody',
            'bear',
            'babylove',
            'jbshare',
            'guiding'
        ];
        const buffLabelMap = {
            blueboost: 'Blue Boost',
            redboost: 'Red Boost',
            whiteboost: 'White Boost',
            haste: 'Haste',
            focus: 'Focus',
            bombcombo: 'Bomb Combo',
            balloonaura: 'Balloon',
            inspire: 'Inspire',
            reindeerfetch: 'Antlers',
            honeymark: 'Honey Mark',
            pollenmark: 'Pollen Mark',
            festivemark: 'Festive Mark',
            popstar: 'Pop Star',
            melody: 'Melody',
            bear: 'Bear Morph',
            babylove: 'Baby Love',
            jbshare: 'Beans',
            guiding: 'Guiding Star'
        };

        function applyBuffFilter() {
            const items = document.querySelectorAll('.buff-item[data-buff]');
            for (const item of items) {
                const name = item.dataset.buff;
                item.classList.toggle('buff-hidden', buffFilterHidden.has(name));
            }
            updateBuffLayout();
        }

        function saveBuffFilter() {
            try {
                localStorage.setItem('statMonitorHiddenBuffs', JSON.stringify(Array.from(buffFilterHidden)));
            } catch (err) {}
        }

        function initBuffFilter() {
            if (buffFilterReady) return;
            const panel = document.getElementById('buff-filter-panel');
            const button = document.getElementById('buff-filter-btn');
            if (!panel || !button) return;

            buffFilterReady = true;
            try {
                const saved = JSON.parse(localStorage.getItem('statMonitorHiddenBuffs') || '[]');
                if (Array.isArray(saved)) buffFilterHidden = new Set(saved);
            } catch (err) {}

            panel.innerHTML = '';
            for (const name of buffFilterOrder) {
                const itemEl = document.querySelector(`.buff-item[data-buff="${name}"]`);
                if (!itemEl) continue;

                const entry = document.createElement('label');
                entry.className = 'buffs-filter-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = !buffFilterHidden.has(name);
                const text = document.createElement('span');
                text.textContent = buffLabelMap[name] || name;

                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        buffFilterHidden.delete(name);
                    } else {
                        buffFilterHidden.add(name);
                    }
                    applyBuffFilter();
                    saveBuffFilter();
                });

                entry.appendChild(checkbox);
                entry.appendChild(text);
                panel.appendChild(entry);
            }

            applyBuffFilter();
            updateBuffLayout();

            button.addEventListener('click', (event) => {
                event.stopPropagation();
                panel.classList.toggle('open');
            });
            panel.addEventListener('click', (event) => {
                event.stopPropagation();
            });
            document.addEventListener('click', () => {
                if (!panel.classList.contains('open')) return;
                panel.classList.remove('open');
            });
        }

        function updateBuffs(buffs) {
            if (!Array.isArray(buffs)) return;
            const icons = window.BUFF_ICON_SOURCES || {};
            const singleStack = new Set(['bear', 'babylove', 'jbshare', 'guiding', 'popstar', 'melody', 'honeymark', 'pollenmark', 'festivemark']);
            for (const [name, iconPath] of Object.entries(icons)) {
                const iconEl = document.getElementById(`buff-icon-${name}`);
                if (!iconEl || !iconPath) continue;
                if (!iconEl.src) iconEl.src = iconPath;
                const wrapper = iconEl.closest('.buff-icon-wrap');
                if (wrapper) wrapper.style.setProperty('--buff-icon', `url('${iconPath}')`);
                const valEl = document.getElementById(`buff-val-${name}`);
                if (valEl && singleStack.has(name)) {
                    valEl.textContent = '';
                    valEl.style.display = 'none';
                }
            }
            const hasAnyNonZero = buffs.some((buff) => Number(buff.value || 0) > 0);
            if (!hasAnyNonZero && Array.isArray(lastBuffs)) {
                const hadAnyNonZero = lastBuffs.some((buff) => Number(buff.value || 0) > 0);
                if (hadAnyNonZero) return;
            }

            for (const buff of buffs) {
                const name = buff.name;
                const valEl = document.getElementById(`buff-val-${name}`);
                const iconEl = document.getElementById(`buff-icon-${name}`);
                if (!valEl || !iconEl) continue;

                const value = Number(buff.value || 0);
                const isSingle = singleStack.has(name);
                if (isSingle) {
                    valEl.textContent = '';
                    valEl.style.display = 'none';
                } else {
                    valEl.textContent = `x${value}`;
                    valEl.style.display = 'block';
                }
                const iconPath = icons[name];
                if (iconPath) iconEl.src = iconPath;
                const wrapper = iconEl.closest('.buff-icon-wrap');
                if (wrapper) {
                    const fill = isSingle ? (value > 0 ? 100 : 0) : Math.max(0, Math.min(10, value)) * 10;
                    wrapper.style.setProperty('--buff-icon', `url('${iconPath || ''}')`);
                    wrapper.style.setProperty('--buff-fill', `${fill}%`);
                }
            }

            lastBuffs = buffs.map((buff) => ({ name: buff.name, value: Number(buff.value || 0) }));
        }

        function updatePlanters(planters) {
            for (let i = 1; i <= 3; i++) {
                const data = Array.isArray(planters) ? planters[i - 1] : null;
                const slot = document.getElementById(`planter-slot-${i}`);
                const fieldEl = document.getElementById(`planter-field-${i}`);
                const timerEl = document.getElementById(`planter-timer-${i}`);
                const planterIcon = document.getElementById(`planter-icon-${i}`);
                const nectarInline = document.getElementById(`nectar-inline-${i}`);

                if (!data || !data.name || data.name === 'None') {
                    slot.classList.add('empty');
                    fieldEl.textContent = 'Empty';
                    timerEl.textContent = '--';
                    planterIcon.style.display = 'none';
                    nectarInline.style.display = 'none';
                    continue;
                }

                slot.classList.remove('empty');
                const fieldName = data.field || data.fieldName || data.planterField || data.location || '';
                fieldEl.textContent = fieldName && fieldName !== 'None' ? fieldName : '--';
                planterIcon.src = getPlanterImage(data.name);
                planterIcon.style.display = 'block';

                if (data.nectar && data.nectar !== 'None') {
                    nectarInline.src = getNectarImage(data.nectar);
                    nectarInline.style.display = 'block';
                } else {
                    nectarInline.style.display = 'none';
                }

                const harvestTime = Number(data.harvestTime || 0);
                if (!harvestTime) {
                    timerEl.textContent = '--';
                } else {
                    const remaining = harvestTime - Math.floor(Date.now() / 1000);
                    timerEl.textContent = remaining <= 0 ? 'Ready' : formatTimer(remaining);
                }
            }
        }

        function updateHeaderLayout() {
            const header = document.querySelector('.stats-header');
            const plantersBox = document.querySelector('.planters-box');
            const buffsGrid = document.querySelector('.buffs-grid');
            if (!header || !plantersBox || !buffsGrid) return;
            const headerWidth = header.clientWidth;
            const count = Number(getComputedStyle(buffsGrid).getPropertyValue('--buff-count')) || 1;
            const gap = 16;
            const honeyMin = 140;
            const backpackMin = 140;
            const plantersMin = 420;
            const nectarMin = 320;
            const buffsMinSize = 20;
            const buffsMinWidth = Math.max(0, count * buffsMinSize + (count - 1) * 2);
            const requiredAll = honeyMin + backpackMin + buffsMinWidth + plantersMin + nectarMin + gap * 4;
            const forceSecondRow = headerWidth < requiredAll;
            header.classList.toggle('force-second-row', forceSecondRow);
            if (forceSecondRow) {
                const secondRowWidth = headerWidth - gap;
                if (plantersMin + nectarMin > secondRowWidth) {
                    plantersBox.style.minWidth = `${Math.max(300, secondRowWidth - nectarMin)}px`;
                } else {
                    plantersBox.style.minWidth = `${plantersMin}px`;
                }
            } else {
                plantersBox.style.minWidth = '';
            }
        }

        function updateChartSubtitleVisibility() {
            const chartBox = document.querySelector('.chart-box');
            if (!chartBox) return;
            const wraps = chartBox.querySelectorAll('.chart-canvas-wrap');
            let minHeight = Infinity;
            for (const wrap of wraps) {
                const height = wrap.clientHeight || 0;
                if (!height) continue;
                minHeight = Math.min(minHeight, height);
            }
            if (minHeight === Infinity) return;
            const compactOn = 90;
            const compactOff = 130;
            let nextCompact = chartSubtitlesCompact;
            if (!chartSubtitlesCompact && minHeight < compactOn) nextCompact = true;
            if (chartSubtitlesCompact && minHeight > compactOff) nextCompact = false;
            if (nextCompact !== chartSubtitlesCompact) {
                chartSubtitlesCompact = nextCompact;
                chartBox.classList.toggle('compact-subtitles', chartSubtitlesCompact);
                scheduleChartResize();
            }
        }

        function scheduleChartResize() {
            if (chartResizeQueued) return;
            chartResizeQueued = true;
            requestAnimationFrame(() => {
                chartResizeQueued = false;
                updateHeaderLayout();
                resizeHoneyCanvas();
                resizePollenCanvas();
                resizeBuffUptimeCanvas();
                updateChartSubtitleVisibility();
            });
        }

        function updateBuffLayout() {
            const grid = document.querySelector('.buffs-grid');
            if (!grid) return;
            const visible = grid.querySelectorAll('.buff-item:not(.buff-hidden)').length;
            const count = visible > 0 ? visible : 1;
            grid.style.setProperty('--buff-count', count);
            const gap = parseFloat(getComputedStyle(grid).getPropertyValue('--buff-gap')) || 0;
            const width = grid.clientWidth;
            const size = Math.max(20, Math.min(44, (width - gap * (count - 1)) / count));
            grid.style.setProperty('--buff-size', `${size}px`);
            updateHeaderLayout();
        }

        function displayStats() {
            const honeyEl = document.getElementById('honey-value');
            const honeyRateEl = document.getElementById('honey-rate');
            const backpackRateEl = document.getElementById('backpack-rate');
            const backpackEl = document.getElementById('backpack-value');
            const backpackText = document.getElementById('backpack-text');
            const backpackBar = document.getElementById('backpack-bar');

            if (typeof statData !== 'undefined' && statData) {
                if (statData.honey !== undefined) {
                    honeyEl.textContent = formatHoney(statData.honey);
                }
                if (honeyRateEl) {
                    honeyRateEl.textContent = formatRate(statData.honey_rate || 0);
                }
                if (statData.honey !== undefined) {
                    updateHoneyChart(statData.honey);
                }
                if (statData.backpack !== undefined) {
                    const bp = Math.min(100, Math.max(0, statData.backpack));
                    const color = getBackpackColor(bp);
                    backpackText.textContent = bp + '%';
                    backpackBar.style.width = bp + '%';
                    backpackBar.style.backgroundColor = color;
                    updatePollenChart(bp);
                }
                if (backpackRateEl) {
                    backpackRateEl.textContent = formatRate(statData.backpack_rate || 0);
                }
                if (Array.isArray(statData.buffs)) {
                    updateBuffUptimeChart(statData.buffs);
                }
                initBuffFilter();
                updateBuffs(statData.buffs);
                updatePlanters(statData.planters);
                updateNectars(statData.nectars);
                updateHeaderLayout();
                updateBuffLayout();
            }
        }

        function reloadStats() {
            const oldScript = document.getElementById('stats-script');
            if (oldScript) oldScript.remove();

            const script = document.createElement('script');
            script.id = 'stats-script';
            script.src = 'stat_monitor_stats.js?t=' + Date.now();
            script.onload = displayStats;
            script.onerror = function() {};
            document.head.appendChild(script);
        }

        let pollenCanvas = null;
        let pollenCtx = null;
        const pollenSeries = [];
        let pollenWindowMs = 60 * 60 * 1000;
        const pollenWindowMinMs = 60 * 1000;
        const pollenWindowMaxMs = 6 * 60 * 60 * 1000;
        const chartLeftPad = 52;
        let pollenViewOffsetMs = 0;
        let pollenPlotWidth = 0;
        let pollenDrag = null;
        let pollenUserPanned = false;
        let pollenHistoryLoaded = false;
        let historyRetryTimer = null;
        const pollenStorageKey = 'statMonitorPollenSeries';
        let pollenLastSave = 0;
        let honeyCanvas = null;
        let honeyCtx = null;
        const honeySeries = [];
        const honeySamples = [];
        let honeyLastSampleAt = 0;
        let honeyHistoryLoaded = false;
        const honeyStorageKey = 'statMonitorHoneyRateSeries';
        let honeyLastSave = 0;
        let honeyActivityTimeline = [];
        let currentActivity = 'other';
        let buffUptimeCanvas = null;
        let buffUptimeCtx = null;
        const buffUptimeSamples = {
            redboost: [],
            whiteboost: [],
            blueboost: [],
            haste: [],
            focus: [],
            bombcombo: [],
            balloonaura: [],
            reindeerfetch: [],
            honeymark: [],
            pollenmark: [],
            melody: [],
            bear: [],
            babylove: [],
            jbshare: [],
            guiding: [],
            popstar: [],
            festivemark: []
        };
        const buffUptimeLastSampleAt = {
            redboost: 0,
            whiteboost: 0,
            blueboost: 0,
            haste: 0,
            focus: 0,
            bombcombo: 0,
            balloonaura: 0,
            reindeerfetch: 0,
            honeymark: 0,
            pollenmark: 0,
            melody: 0,
            bear: 0,
            babylove: 0,
            jbshare: 0,
            guiding: 0,
            popstar: 0,
            festivemark: 0
        };
        const buffIconImages = new Map();
        let chartRenderQueued = false;
        let chartResizeQueued = false;
        let chartSubtitlesCompact = false;

        const zoomSteps = [
            { label: '6h', ms: 6 * 60 * 60 * 1000 },
            { label: '3h', ms: 3 * 60 * 60 * 1000 },
            { label: '2h', ms: 2 * 60 * 60 * 1000 },
            { label: '90m', ms: 90 * 60 * 1000 },
            { label: '1h', ms: 60 * 60 * 1000 },
            { label: '30m', ms: 30 * 60 * 1000 },
            { label: '15m', ms: 15 * 60 * 1000 },
            { label: '10m', ms: 10 * 60 * 1000 },
            { label: '5m', ms: 5 * 60 * 1000 }
        ];

        function ensureBuffUptimeCanvas() {
            if (buffUptimeCanvas) return;
            buffUptimeCanvas = document.getElementById('buff-uptime-chart');
            if (!buffUptimeCanvas) return;
            buffUptimeCanvas.addEventListener('wheel', onPollenWheel, { passive: false });
            buffUptimeCanvas.addEventListener('pointerdown', onPollenDragStart);
            buffUptimeCanvas.addEventListener('mousedown', onPollenMouseDown);
            resizeBuffUptimeCanvas();
        }

        function resizeBuffUptimeCanvas() {
            if (!buffUptimeCanvas) return;
            const rect = buffUptimeCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const width = Math.max(1, Math.floor(rect.width * dpr));
            const height = Math.max(1, Math.floor(rect.height * dpr));
            buffUptimeCanvas.width = width;
            buffUptimeCanvas.height = height;
            buffUptimeCtx = buffUptimeCanvas.getContext('2d');
            buffUptimeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            drawBuffUptimeChart();
        }

        function updateBuffUptimeChart(buffs) {
            ensureBuffUptimeCanvas();
            if (!buffUptimeCanvas) return;
            const now = Date.now();
            const lookup = new Map();
            for (const buff of buffs) {
                if (!buff || !buff.name) continue;
                lookup.set(buff.name, Number(buff.value || 0));
            }
            for (const name of ['whiteboost', 'redboost', 'blueboost', 'haste', 'focus', 'bombcombo', 'balloonaura', 'reindeerfetch', 'honeymark', 'pollenmark', 'festivemark', 'popstar', 'melody', 'bear', 'babylove', 'jbshare', 'guiding']) {
                const lastAt = buffUptimeLastSampleAt[name] || 0;
                if (now - lastAt >= 1000) {
                    const value = Math.max(0, lookup.get(name) || 0);
                    buffUptimeSamples[name].push({ t: now, v: value });
                    buffUptimeLastSampleAt[name] = now;
                }
            }
            const cutoff = now - pollenWindowMaxMs;
            for (const name of ['whiteboost', 'redboost', 'blueboost', 'haste', 'focus', 'bombcombo', 'balloonaura', 'reindeerfetch', 'honeymark', 'pollenmark', 'festivemark', 'popstar', 'melody', 'bear', 'babylove', 'jbshare', 'guiding']) {
                while (buffUptimeSamples[name].length && buffUptimeSamples[name][0].t < cutoff) {
                    buffUptimeSamples[name].shift();
                }
            }
            drawBuffUptimeChart();
        }

        function buildBuffPoints(samples, start, viewEnd, plotW, maxValue = 10) {
            let previous = null;
            const points = [];
            for (const sample of samples) {
                if (sample.t < start) {
                    previous = sample;
                    continue;
                }
                if (sample.t > viewEnd) break;
                points.push(sample);
            }
            if (previous && points.length) {
                points.unshift({ t: start, v: previous.v });
            } else if (previous && points.length === 0) {
                points.push({ t: start, v: previous.v });
            }
            if (points.length) {
                const last = points[points.length - 1];
                if (last.t < viewEnd) {
                    points.push({ t: viewEnd, v: last.v });
                }
            }
            if (points.length < 2) return [];
            return points.map((point) => ({
                x: ((point.t - start) / pollenWindowMs) * plotW,
                y: 1 - Math.min(maxValue, Math.max(0, point.v)) / maxValue
            }));
        }

        function computeBuffAverage(samples, start, viewEnd) {
            if (samples.length < 2) return 0;
            let total = 0;
            let duration = 0;
            let gathered = 0;
            let gatherDuration = 0;
            for (let i = 0; i < samples.length - 1; i++) {
                const a = samples[i];
                const b = samples[i + 1];
                const segStart = Math.max(start, a.t);
                const segEnd = Math.min(viewEnd, b.t);
                if (segEnd <= segStart) continue;
                const segDuration = (segEnd - segStart) / 1000;
                const mid = (segStart + segEnd) / 2;
                if (getActivityAt(mid) === 'gather') {
                    gathered += a.v * segDuration;
                    gatherDuration += segDuration;
                }
                total += a.v * segDuration;
                duration += segDuration;
            }
            if (gatherDuration > 0) return gathered / gatherDuration;
            if (duration > 0) return total / duration;
            return 0;
        }

        function drawBuffUptimeChart() {
            if (!buffUptimeCanvas || !buffUptimeCtx) return;
            const rect = buffUptimeCanvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            if (width <= 0 || height <= 0) return;

            const ctx = buffUptimeCtx;
            ctx.clearRect(0, 0, width, height);

            const pad = { top: 10, right: 0, bottom: 36, left: chartLeftPad };
            const plotH = Math.max(1, height - pad.top - pad.bottom);
            const plotW = Math.max(1, width - pad.left - pad.right);

            const bgGradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
            bgGradient.addColorStop(0, '#1c1a1b');
            bgGradient.addColorStop(1, '#141314');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(pad.left, pad.top, width - pad.left, plotH);

            const now = Date.now();
            const viewEnd = now - pollenViewOffsetMs;
            const start = viewEnd - pollenWindowMs;

            const halfHourMs = 30 * 60 * 1000;
            const tenMinMs = 10 * 60 * 1000;
            const oneMinMs = 60 * 1000;
            const showMinuteGrid = pollenWindowMs <= 30 * 60 * 1000 && plotH >= 90;
            const showColumns = true;
            const showRows = plotH >= 70;
            const firstMajor = Math.floor(start / halfHourMs) * halfHourMs;
            const lastMajor = Math.ceil(viewEnd / halfHourMs) * halfHourMs;
            if (showColumns) {
                ctx.lineWidth = 1;
                for (let t = firstMajor; t <= lastMajor; t += halfHourMs) {
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.45)';
                    ctx.beginPath();
                    ctx.moveTo(x, pad.top);
                    ctx.lineTo(x, pad.top + plotH);
                    ctx.stroke();
                }
                const firstTen = Math.floor(start / tenMinMs) * tenMinMs;
                const lastTen = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
                for (let t = firstTen; t <= lastTen; t += tenMinMs) {
                    if (t % halfHourMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(x, pad.top);
                    ctx.lineTo(x, pad.top + plotH);
                    ctx.stroke();
                }
                if (showMinuteGrid) {
                    const firstMin = Math.floor(start / oneMinMs) * oneMinMs;
                    const lastMin = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                    for (let t = firstMin; t <= lastMin; t += oneMinMs) {
                        if (t % tenMinMs === 0) continue;
                        const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                        if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                        ctx.strokeStyle = 'rgba(192, 192, 240, 0.12)';
                        ctx.beginPath();
                        ctx.moveTo(x, pad.top);
                        ctx.lineTo(x, pad.top + plotH);
                        ctx.stroke();
                    }
                }
            }
            const colors = {
                whiteboost: '#ffffff',
                redboost: '#e46156',
                blueboost: '#56a4e4',
                haste: '#f0f0f0',
                focus: '#22ff06',
                bombcombo: '#4b4b4b',
                balloonaura: '#fafd38',
                reindeerfetch: '#cc2c2c',
                honeymark: '#f2b13f',
                pollenmark: '#f2d55b',
                melody: '#b0b0b0',
                bear: '#c7a26a',
                babylove: '#8de4f3',
                jbshare: '#f9ccff',
                guiding: '#8cc7ff',
                popstar: '#f5a3ff',
                festivemark: '#ffd86b'
            };
            const buffBands = [
                { type: 'boost', names: ['whiteboost', 'redboost', 'blueboost'] },
                { type: 'single', name: 'haste' },
                { type: 'single', name: 'focus' },
                { type: 'single', name: 'bombcombo' },
                { type: 'single', name: 'balloonaura' },
                { type: 'single', name: 'reindeerfetch' },
                { type: 'binary', name: 'honeymark' },
                { type: 'binary', name: 'pollenmark' },
                { type: 'binary', name: 'festivemark' },
                { type: 'binary', name: 'popstar' },
                { type: 'binary', name: 'melody' },
                { type: 'binary', name: 'bear' },
                { type: 'binary', name: 'babylove' },
                { type: 'binary', name: 'jbshare' },
                { type: 'binary', name: 'guiding' }
            ];
            const separatorThickness = 1;
            const bandCount = buffBands.length;
            const availableH = Math.max(1, plotH - separatorThickness * (bandCount - 1));
            const bandH = availableH / bandCount;
            const iconSize = Math.max(2, Math.min(24, Math.round(Math.min(plotH * 0.13, bandH * 0.6))));
            const textSize = Math.max(5, Math.min(10, Math.round(iconSize * 0.45)));
            const lineHeight = Math.max(8, Math.round(textSize * 1.1));
            const iconGap = 6;
            const leftAreaWidth = pad.left;
            const comboBox = iconSize;
            const comboLeft = Math.max(4, Math.round((leftAreaWidth - comboBox) / 2));
            const textX = Math.round(leftAreaWidth / 2);

            for (let i = 0; i < bandCount; i++) {
                const bandTop = pad.top + i * (bandH + separatorThickness);
                const y = bandTop + bandH / 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(pad.left + plotW, y);
                ctx.stroke();
            }

            for (let i = 1; i < bandCount; i++) {
                const y = pad.top + i * bandH + (i - 1) * separatorThickness + 0.5;
                ctx.strokeStyle = i === 1 ? 'rgba(192, 192, 240, 0.35)' : 'rgba(192, 192, 240, 0.2)';
                ctx.lineWidth = separatorThickness;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(pad.left + plotW, y);
                ctx.stroke();
            }

            for (let i = 0; i < buffBands.length; i++) {
                const band = buffBands[i];
                const bandTop = pad.top + i * (bandH + separatorThickness);
                ctx.save();
                ctx.beginPath();
                ctx.rect(pad.left, bandTop, width - pad.left, bandH);
                ctx.clip();

                if (band.type === 'boost') {
                    for (const name of band.names) {
                        const samples = buffUptimeSamples[name] || [];
                        const points = buildBuffPoints(samples, start, viewEnd, plotW);
                        if (points.length < 2) continue;
                        const color = colors[name];

                        ctx.beginPath();
                        for (let j = 0; j < points.length; j++) {
                            const point = points[j];
                            const x = pad.left + point.x;
                            const y = bandTop + point.y * bandH;
                            if (j === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        const lastX = pad.left + points[points.length - 1].x;
                        const firstX = pad.left + points[0].x;
                        ctx.lineTo(lastX, bandTop + bandH);
                        ctx.lineTo(firstX, bandTop + bandH);
                        ctx.closePath();
                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.restore();

                        ctx.lineWidth = 2;
                        ctx.strokeStyle = color;
                        ctx.beginPath();
                        for (let j = 0; j < points.length; j++) {
                            const point = points[j];
                            const x = pad.left + point.x;
                            const y = bandTop + point.y * bandH;
                            if (j === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                } else if (band.type === 'binary') {
                    const name = band.name;
                    const samples = buffUptimeSamples[name] || [];
                    if (samples.length) {
                        let previous = null;
                        for (const sample of samples) {
                            if (sample.t < start) {
                                previous = sample;
                                continue;
                            }
                            const segStart = Math.max(start, previous ? previous.t : start);
                            const segEnd = Math.min(viewEnd, sample.t);
                            if (segEnd > segStart && previous && previous.v > 0) {
                                const x0 = pad.left + ((segStart - start) / pollenWindowMs) * plotW;
                                const x1 = pad.left + ((segEnd - start) / pollenWindowMs) * plotW;
                                ctx.save();
                                ctx.globalAlpha = 0.35;
                                ctx.fillStyle = colors[name] || '#f0f0f0';
                                ctx.fillRect(x0, bandTop, x1 - x0, bandH);
                                ctx.restore();
                            }
                            previous = sample;
                            if (sample.t > viewEnd) break;
                        }
                        if (previous && previous.t < viewEnd && previous.v > 0) {
                            const segStart = Math.max(start, previous.t);
                            const x0 = pad.left + ((segStart - start) / pollenWindowMs) * plotW;
                            const x1 = pad.left + plotW;
                            ctx.save();
                            ctx.globalAlpha = 0.35;
                            ctx.fillStyle = colors[name] || '#f0f0f0';
                            ctx.fillRect(x0, bandTop, x1 - x0, bandH);
                            ctx.restore();
                        }
                    }
                } else {
                    const name = band.name;
                    const samples = buffUptimeSamples[name] || [];
                    const points = buildBuffPoints(samples, start, viewEnd, plotW);
                    if (points.length >= 2) {
                        const color = colors[name] || '#f0f0f0';
                        ctx.beginPath();
                        for (let j = 0; j < points.length; j++) {
                            const point = points[j];
                            const x = pad.left + point.x;
                            const y = bandTop + point.y * bandH;
                            if (j === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        const lastX = pad.left + points[points.length - 1].x;
                        const firstX = pad.left + points[0].x;
                        ctx.lineTo(lastX, bandTop + bandH);
                        ctx.lineTo(firstX, bandTop + bandH);
                        ctx.closePath();
                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.restore();

                        ctx.lineWidth = 2;
                        ctx.strokeStyle = color;
                        ctx.beginPath();
                        for (let j = 0; j < points.length; j++) {
                            const point = points[j];
                            const x = pad.left + point.x;
                            const y = bandTop + point.y * bandH;
                            if (j === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            ctx.fillStyle = '#8a8a8a';
            ctx.font = `${textSize}px Segoe UI`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'center';

            const comboIcon = getBuffIconImage('boost');
            const boostBandTop = pad.top;
            const boostBlockHeight = iconSize;
            let boostBlockTop = Math.round(boostBandTop + (bandH - boostBlockHeight) / 2);
            const boostMinY = boostBandTop + 2;
            const boostMaxY = boostBandTop + bandH - boostBlockHeight - 2;
            if (boostBlockTop < boostMinY) boostBlockTop = boostMinY;
            if (boostBlockTop > boostMaxY) boostBlockTop = boostMaxY;
            const boostIconY = boostBlockTop;
            if (comboIcon && comboIcon.complete) {
                ctx.drawImage(comboIcon, comboLeft, boostIconY, iconSize, iconSize);
            }
            for (const name of ['redboost', 'whiteboost', 'blueboost']) {
                void name;
            }

            for (let i = 1; i < buffBands.length; i++) {
                const band = buffBands[i];
                if (band.type === 'boost') continue;
                const bandTop = pad.top + i * (bandH + separatorThickness);
                const bandBlockHeight = iconSize;
                let bandBlockTop = Math.round(bandTop + (bandH - bandBlockHeight) / 2);
                const bandMinY = bandTop + 2;
                const bandMaxY = bandTop + bandH - bandBlockHeight - 2;
                if (bandBlockTop < bandMinY) bandBlockTop = bandMinY;
                if (bandBlockTop > bandMaxY) bandBlockTop = bandMaxY;
                const icon = getBuffIconImage(band.name);
                if (icon && icon.complete) {
                    ctx.drawImage(icon, comboLeft, bandBlockTop, iconSize, iconSize);
                }
                if (band.type !== 'binary') {
                    ctx.fillStyle = colors[band.name] || '#f0f0f0';
                }
            }

            const showTimeAxis = plotH >= 110 && plotW >= 220;
            if (showTimeAxis) {
                const tickLabels = [];
                const firstLabel = Math.floor(start / tenMinMs) * tenMinMs;
                const lastLabel = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
                for (let t = firstLabel; t <= lastLabel; t += tenMinMs) {
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    tickLabels.push({ t, x });
                }
                const tickBaseY = pad.top + plotH + 1;
                ctx.fillStyle = '#8a8a8a';
                ctx.font = '11px Segoe UI';
                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                ctx.lineWidth = 2;
                for (const label of tickLabels) {
                    const isHalfHour = label.t % halfHourMs === 0;
                    const isTenMin = label.t % tenMinMs === 0;
                    const isMinute = label.t % oneMinMs === 0;
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    const tickHeight = Math.max(4, Math.round((isHalfHour ? 14 : isTenMin ? 11 : 7) * scale));
                    const alignedX = Math.round(label.x) + 0.5;
                    const tickTop = Math.round(tickBaseY) + 0.5;
                    const tickBottom = Math.round(tickBaseY + tickHeight) + 0.5;
                    ctx.strokeStyle = isHalfHour ? 'rgba(192, 192, 240, 0.65)' : isTenMin ? 'rgba(192, 192, 240, 0.45)' : isMinute ? 'rgba(192, 192, 240, 0.3)' : 'rgba(192, 192, 240, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickTop);
                    ctx.lineTo(alignedX, tickBottom);
                    ctx.stroke();
                    ctx.fillText(formatClockTime(label.t), Math.round(label.x), tickBaseY + 18);
                }
                const minorStart = Math.floor(start / oneMinMs) * oneMinMs;
                const minorEnd = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                for (let t = minorStart; t <= minorEnd; t += oneMinMs) {
                    if (t % tenMinMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    const alignedX = Math.round(x) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickBaseY);
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    ctx.lineTo(alignedX, tickBaseY + Math.max(4, Math.round(7 * scale)));
                    ctx.stroke();
                }
            }
        }

        function ensureHoneyCanvas() {
            if (honeyCanvas) return;
            honeyCanvas = document.getElementById('honey-chart');
            if (!honeyCanvas) return;
            honeyCanvas.addEventListener('wheel', onPollenWheel, { passive: false });
            honeyCanvas.addEventListener('pointerdown', onPollenDragStart);
            honeyCanvas.addEventListener('mousedown', onPollenMouseDown);
            resizeHoneyCanvas();
        }

        function resizeHoneyCanvas() {
            if (!honeyCanvas) return;
            const rect = honeyCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const width = Math.max(1, Math.floor(rect.width * dpr));
            const height = Math.max(1, Math.floor(rect.height * dpr));
            honeyCanvas.width = width;
            honeyCanvas.height = height;
            honeyCtx = honeyCanvas.getContext('2d');
            honeyCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            drawHoneyChart();
        }

        function updateHoneyChart(value) {
            ensureHoneyCanvas();
            if (!honeyCanvas) return;
            const num = Number(value);
            if (!isNaN(num)) {
                const now = Date.now();
                if (!honeyLastSampleAt || now - honeyLastSampleAt >= 1000) {
                    honeySamples.push({ t: now, v: Math.max(0, num) });
                    honeyLastSampleAt = now;
                }
            }
            rebuildHoneySeries();
            drawHoneyChart();
        }

        function rebuildHoneySeries() {
            const cutoff = Date.now() - pollenWindowMaxMs;
            while (honeySamples.length && honeySamples[0].t < cutoff) {
                honeySamples.shift();
            }
            if (honeySamples.length < 2) {
                honeySeries.length = 0;
                return;
            }

            const minuteMap = new Map();
            for (const sample of honeySamples) {
                const minuteStart = Math.floor(sample.t / 60000) * 60000;
                minuteMap.set(minuteStart, sample.v);
            }

            const minuteKeys = Array.from(minuteMap.keys()).sort((a, b) => a - b);
            const filled = new Map();
            for (let i = 0; i < minuteKeys.length; i++) {
                const t1 = minuteKeys[i];
                const v1 = minuteMap.get(t1);
                filled.set(t1, v1);
                const t2 = minuteKeys[i + 1];
                if (!t2) continue;
                const v2 = minuteMap.get(t2);
                const stepCount = Math.round((t2 - t1) / 60000);
                if (stepCount > 1) {
                    for (let j = 1; j < stepCount; j++) {
                        const tFill = t1 + j * 60000;
                        const ratio = j / stepCount;
                        filled.set(tFill, v1 + (v2 - v1) * ratio);
                    }
                }
            }

            const filledKeys = Array.from(filled.keys()).sort((a, b) => a - b);
            honeySeries.length = 0;
            for (let i = 0; i < filledKeys.length - 1; i++) {
                const t1 = filledKeys[i];
                const t2 = filledKeys[i + 1];
                const v1 = filled.get(t1);
                const v2 = filled.get(t2);
                const seconds = Math.max(1, (t2 - t1) / 1000);
                const rate = Math.max(0, (v2 - v1) / seconds);
                honeySeries.push({ t: t1, v: rate, activity: getActivityAt(t1) });
            }

            const lastKey = filledKeys[filledKeys.length - 1];
            if (lastKey !== undefined && honeySeries.length) {
                const lastRate = honeySeries[honeySeries.length - 1].v;
                honeySeries.push({ t: lastKey, v: lastRate, activity: getActivityAt(lastKey) });
            }
        }

        function drawHoneyChart() {
            if (!honeyCanvas || !honeyCtx) return;
            const rect = honeyCanvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            if (width <= 0 || height <= 0) return;

            const ctx = honeyCtx;
            ctx.clearRect(0, 0, width, height);

            const showTimeAxis = height >= 90 && width >= 180;
            const pad = { top: 12, right: 0, bottom: showTimeAxis ? 36 : 12, left: chartLeftPad };
            const plotW = Math.max(1, width - pad.left - pad.right);
            const plotH = Math.max(1, height - pad.top - pad.bottom);

            const bgGradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
            bgGradient.addColorStop(0, '#1c1a1b');
            bgGradient.addColorStop(1, '#141314');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(pad.left, pad.top, width - pad.left, plotH);

            ctx.save();
            ctx.beginPath();
            ctx.rect(pad.left, pad.top, width - pad.left, plotH);
            ctx.clip();

            const now = Date.now();
            const viewEnd = now - pollenViewOffsetMs;
            const start = viewEnd - pollenWindowMs;

            const halfHourMs = 30 * 60 * 1000;
            const tenMinMs = 10 * 60 * 1000;
            const oneMinMs = 60 * 1000;
            const showMinuteGrid = pollenWindowMs <= 30 * 60 * 1000;
            const firstMajor = Math.floor(start / halfHourMs) * halfHourMs;
            const lastMajor = Math.ceil(viewEnd / halfHourMs) * halfHourMs;
            ctx.lineWidth = 1;
            for (let t = firstMajor; t <= lastMajor; t += halfHourMs) {
                const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.45)';
                ctx.beginPath();
                ctx.moveTo(x, pad.top);
                ctx.lineTo(x, pad.top + plotH);
                ctx.stroke();
            }
            const firstTen = Math.floor(start / tenMinMs) * tenMinMs;
            const lastTen = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
            for (let t = firstTen; t <= lastTen; t += tenMinMs) {
                if (t % halfHourMs === 0) continue;
                const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x, pad.top);
                ctx.lineTo(x, pad.top + plotH);
                ctx.stroke();
            }
            if (showMinuteGrid) {
                const firstMin = Math.floor(start / oneMinMs) * oneMinMs;
                const lastMin = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                for (let t = firstMin; t <= lastMin; t += oneMinMs) {
                    if (t % tenMinMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.12)';
                    ctx.beginPath();
                    ctx.moveTo(x, pad.top);
                    ctx.lineTo(x, pad.top + plotH);
                    ctx.stroke();
                }
            }

            if (plotH >= 70) {
                for (let i = 1; i <= 3; i++) {
                    const y = pad.top + (plotH * i) / 4;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            } else {
                const y = pad.top + plotH / 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.2)';
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            let previous = null;
            const points = [];
            for (const point of honeySeries) {
                if (point.t < start) {
                    previous = point;
                    continue;
                }
                if (point.t > viewEnd) break;
                points.push(point);
            }
            if (previous && points.length) {
                points.unshift({ t: start, v: previous.v, activity: previous.activity });
            } else if (previous && points.length === 0) {
                points.push({ t: start, v: previous.v, activity: previous.activity });
            }
            if (points.length) {
                const last = points[points.length - 1];
                if (last.t < viewEnd) {
                    points.push({ t: viewEnd, v: last.v, activity: last.activity });
                }
            }

            let maxValue = 0;
            for (const point of points) {
                if (point.v > maxValue) maxValue = point.v;
            }
            if (maxValue <= 0) maxValue = 1;

            if (points.length > 1) {
                const drawSegment = (segment, activity) => {
                    if (segment.length < 2) return;
                    const color = getActivityColor(activity);
                    const firstPoint = segment[0];
                    const lastPoint = segment[segment.length - 1];
                    const firstX = pad.left + ((firstPoint.t - start) / pollenWindowMs) * plotW;
                    const lastX = pad.left + ((lastPoint.t - start) / pollenWindowMs) * plotW;

                    ctx.save();
                    ctx.beginPath();
                    for (let i = 0; i < segment.length; i++) {
                        const point = segment[i];
                        const x = pad.left + ((point.t - start) / pollenWindowMs) * plotW;
                        const y = pad.top + (1 - point.v / maxValue) * plotH;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.lineTo(lastX, pad.top + plotH);
                    ctx.lineTo(firstX, pad.top + plotH);
                    ctx.closePath();
                    ctx.globalAlpha = 0.2;
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.restore();

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < segment.length; i++) {
                        const point = segment[i];
                        const x = pad.left + ((point.t - start) / pollenWindowMs) * plotW;
                        const y = pad.top + (1 - point.v / maxValue) * plotH;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                };

                let segment = [];
                let active = points[0].activity || 'other';
                for (const point of points) {
                    const activity = point.activity || 'other';
                    if (activity !== active) {
                        drawSegment(segment, active);
                        segment = segment.length ? [segment[segment.length - 1], point] : [point];
                        active = activity;
                        continue;
                    }
                    segment.push(point);
                }
                drawSegment(segment, active);
            } else {
                ctx.fillStyle = '#666';
                ctx.font = '11px Segoe UI';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Waiting for honey...', pad.left + plotW / 2, pad.top + plotH / 2);
            }

            ctx.restore();

            ctx.fillStyle = '#8a8a8a';
            ctx.font = '11px Segoe UI';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'right';
            if (plotH >= 70) {
                for (let i = 0; i <= 4; i++) {
                    const value = maxValue - (maxValue * i) / 4;
                    const y = pad.top + (plotH * i) / 4;
                    ctx.fillText(formatHoney(value), pad.left - 6, y);
                }
            } else {
                ctx.fillText(formatHoney(maxValue), pad.left - 6, pad.top);
                ctx.fillText(formatHoney(0), pad.left - 6, pad.top + plotH);
            }

            if (showTimeAxis) {
                const tickLabels = [];
                const firstLabel = Math.floor(start / tenMinMs) * tenMinMs;
                const lastLabel = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
                for (let t = firstLabel; t <= lastLabel; t += tenMinMs) {
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    tickLabels.push({ t, x });
                }
                const tickBaseY = pad.top + plotH + 1;
                ctx.fillStyle = '#8a8a8a';
                ctx.font = '11px Segoe UI';
                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                ctx.lineWidth = 2;
                for (const label of tickLabels) {
                    const isHalfHour = label.t % halfHourMs === 0;
                    const isTenMin = label.t % tenMinMs === 0;
                    const isMinute = label.t % oneMinMs === 0;
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    const tickHeight = Math.max(4, Math.round((isHalfHour ? 14 : isTenMin ? 11 : 7) * scale));
                    const alignedX = Math.round(label.x) + 0.5;
                    const tickTop = Math.round(tickBaseY) + 0.5;
                    const tickBottom = Math.round(tickBaseY + tickHeight) + 0.5;
                    ctx.strokeStyle = isHalfHour ? 'rgba(192, 192, 240, 0.65)' : isTenMin ? 'rgba(192, 192, 240, 0.45)' : isMinute ? 'rgba(192, 192, 240, 0.3)' : 'rgba(192, 192, 240, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickTop);
                    ctx.lineTo(alignedX, tickBottom);
                    ctx.stroke();
                    ctx.fillText(formatClockTime(label.t), Math.round(label.x), tickBaseY + 18);
                }
                const minorStart = Math.floor(start / oneMinMs) * oneMinMs;
                const minorEnd = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                for (let t = minorStart; t <= minorEnd; t += oneMinMs) {
                    if (t % tenMinMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    const alignedX = Math.round(x) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickBaseY);
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    ctx.lineTo(alignedX, tickBaseY + Math.max(4, Math.round(7 * scale)));
                    ctx.stroke();
                }
            }
        }

        function ensurePollenCanvas() {
            if (pollenCanvas) return;
            ensureHoneyCanvas();
            ensureBuffUptimeCanvas();
            pollenCanvas = document.getElementById('pollen-chart');
            if (!pollenCanvas) return;
            pollenCanvas.addEventListener('wheel', onPollenWheel, { passive: false });
            pollenCanvas.addEventListener('pointerdown', onPollenDragStart);
            window.addEventListener('pointerup', onPollenDragEnd);
            window.addEventListener('pointermove', onPollenDragMove);
            pollenCanvas.addEventListener('mousedown', onPollenMouseDown);
            window.addEventListener('mouseup', onPollenMouseUp);
            window.addEventListener('mousemove', onPollenMouseMove);
            window.addEventListener('blur', onPollenMouseUp);
            reloadHistory();
            resizePollenCanvas();
            initChartControls();
        }

        function resizePollenCanvas() {
            if (!pollenCanvas) return;
            const rect = pollenCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const width = Math.max(1, Math.floor(rect.width * dpr));
            const height = Math.max(1, Math.floor(rect.height * dpr));
            pollenCanvas.width = width;
            pollenCanvas.height = height;
            pollenCtx = pollenCanvas.getContext('2d');
            pollenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            drawPollenChart();
        }

        function updatePollenChart(value) {
            ensurePollenCanvas();
            if (!pollenCanvas) return;
            const num = Number(value);
            if (!isNaN(num)) {
                const now = Date.now();
                const last = pollenSeries[pollenSeries.length - 1];
                if (!last || now - last.t >= 1000) {
                    pollenSeries.push({ t: now, v: Math.max(0, Math.min(100, num)) });
                }
                const cutoff = now - pollenWindowMaxMs;
                while (pollenSeries.length && pollenSeries[0].t < cutoff) {
                    pollenSeries.shift();
                }
            }
            drawPollenChart();
        }

        function drawPollenChart() {
            if (!pollenCanvas || !pollenCtx) return;
            const rect = pollenCanvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            if (width <= 0 || height <= 0) return;

            const ctx = pollenCtx;
            ctx.clearRect(0, 0, width, height);

            const showTimeAxis = height >= 90 && width >= 180;
            const pad = { top: 12, right: 0, bottom: showTimeAxis ? 36 : 12, left: chartLeftPad };
            const plotW = Math.max(1, width - pad.left - pad.right);
            const plotH = Math.max(1, height - pad.top - pad.bottom);

            ctx.clearRect(0, 0, width, height);

            const bgGradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
            bgGradient.addColorStop(0, '#1c1a1b');
            bgGradient.addColorStop(1, '#141314');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(pad.left, pad.top, width - pad.left, plotH);

            ctx.save();
            ctx.beginPath();
            ctx.rect(pad.left, pad.top, width - pad.left, plotH);
            ctx.clip();

            const now = Date.now();
            if (!pollenUserPanned) {
                pollenViewOffsetMs = 0;
            } else if (pollenViewOffsetMs <= 0.5) {
                pollenUserPanned = false;
                pollenViewOffsetMs = 0;
            }
            const maxOffset = getPollenMaxOffset(now);
            pollenViewOffsetMs = Math.max(0, Math.min(maxOffset, pollenViewOffsetMs));
            const viewEnd = now - pollenViewOffsetMs;
            const start = viewEnd - pollenWindowMs;
            pollenPlotWidth = plotW;

            const halfHourMs = 30 * 60 * 1000;
            const tenMinMs = 10 * 60 * 1000;
            const oneMinMs = 60 * 1000;
            const showMinuteGrid = pollenWindowMs <= 30 * 60 * 1000;
            const firstMajor = Math.floor(start / halfHourMs) * halfHourMs;
            const lastMajor = Math.ceil(viewEnd / halfHourMs) * halfHourMs;
            ctx.lineWidth = 1;
            for (let t = firstMajor; t <= lastMajor; t += halfHourMs) {
                const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.45)';
                ctx.beginPath();
                ctx.moveTo(x, pad.top);
                ctx.lineTo(x, pad.top + plotH);
                ctx.stroke();
            }
            const firstTen = Math.floor(start / tenMinMs) * tenMinMs;
            const lastTen = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
            for (let t = firstTen; t <= lastTen; t += tenMinMs) {
                if (t % halfHourMs === 0) continue;
                const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x, pad.top);
                ctx.lineTo(x, pad.top + plotH);
                ctx.stroke();
            }
            if (showMinuteGrid) {
                const firstMin = Math.floor(start / oneMinMs) * oneMinMs;
                const lastMin = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                for (let t = firstMin; t <= lastMin; t += oneMinMs) {
                    if (t % tenMinMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.12)';
                    ctx.beginPath();
                    ctx.moveTo(x, pad.top);
                    ctx.lineTo(x, pad.top + plotH);
                    ctx.stroke();
                }
            }
            if (plotH >= 70) {
                for (let i = 1; i <= 3; i++) {
                    const y = pad.top + (plotH * i) / 4;
                    ctx.strokeStyle = 'rgba(192, 192, 240, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            } else {
                const y = pad.top + plotH / 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.2)';
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            let previous = null;
            const points = [];
            for (const point of pollenSeries) {
                if (point.t < start) {
                    previous = point;
                    continue;
                }
                if (point.t > viewEnd) break;
                points.push(point);
            }
            if (previous && points.length) {
                points.unshift({ t: start, v: previous.v });
            } else if (previous && points.length === 0) {
                points.push({ t: start, v: previous.v });
            }
            if (points.length) {
                const last = points[points.length - 1];
                if (last.t < viewEnd) {
                    points.push({ t: viewEnd, v: last.v });
                }
            }

            if (points.length > 1) {
                const fillGradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
                const topRgb = parseRgb(getBackpackColor(100)) || { r: 255, g: 255, b: 255 };
                const midRgb = parseRgb(getBackpackColor(50)) || { r: 255, g: 255, b: 255 };
                const botRgb = parseRgb(getBackpackColor(0)) || { r: 255, g: 255, b: 255 };
                fillGradient.addColorStop(0, `rgba(${topRgb.r}, ${topRgb.g}, ${topRgb.b}, 0.6)`);
                fillGradient.addColorStop(0.5, `rgba(${midRgb.r}, ${midRgb.g}, ${midRgb.b}, 0.5)`);
                fillGradient.addColorStop(1, `rgba(${botRgb.r}, ${botRgb.g}, ${botRgb.b}, 0.18)`);

                const firstPoint = points[0];
                const lastPoint = points[points.length - 1];
                const firstX = pad.left + ((firstPoint.t - start) / pollenWindowMs) * plotW;
                const lastX = pad.left + ((lastPoint.t - start) / pollenWindowMs) * plotW;

                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const x = pad.left + ((point.t - start) / pollenWindowMs) * plotW;
                    const y = pad.top + (1 - point.v / 100) * plotH;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.lineTo(lastX, pad.top + plotH);
                ctx.lineTo(firstX, pad.top + plotH);
                ctx.closePath();
                ctx.fillStyle = fillGradient;
                ctx.fill();

                ctx.lineWidth = 2;
                const strokeGradient = ctx.createLinearGradient(pad.left, 0, pad.left + plotW, 0);
                for (const point of points) {
                    const stop = Math.max(0, Math.min(1, (point.t - start) / pollenWindowMs));
                    strokeGradient.addColorStop(stop, getBackpackColor(point.v));
                }
                ctx.strokeStyle = strokeGradient;
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const x = pad.left + ((point.t - start) / pollenWindowMs) * plotW;
                    const y = pad.top + (1 - point.v / 100) * plotH;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            } else {
                ctx.fillStyle = '#666';
                ctx.font = '11px Segoe UI';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Waiting for pollen...', pad.left + plotW / 2, pad.top + plotH / 2);
            }

            ctx.restore();

            const tickBaseY = pad.top + plotH + 1;
            ctx.fillStyle = '#8a8a8a';
            ctx.font = '11px Segoe UI';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'right';
            if (plotH >= 70) {
                for (let i = 0; i <= 4; i++) {
                    const value = 100 - i * 25;
                    const y = pad.top + (plotH * i) / 4;
                    ctx.fillText(`${value}%`, pad.left - 6, y);
                }
            } else {
                ctx.fillText('100%', pad.left - 6, pad.top);
                ctx.fillText('0%', pad.left - 6, pad.top + plotH);
            }
            ctx.fillStyle = '#8a8a8a';
            ctx.font = '11px Segoe UI';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'center';
            if (showTimeAxis) {
                const tickLabels = [];
                const firstLabel = Math.floor(start / tenMinMs) * tenMinMs;
                const lastLabel = Math.ceil(viewEnd / tenMinMs) * tenMinMs;
                for (let t = firstLabel; t <= lastLabel; t += tenMinMs) {
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    tickLabels.push({ t, x });
                }
                ctx.lineWidth = 2;
                for (const label of tickLabels) {
                    const isHalfHour = label.t % halfHourMs === 0;
                    const isTenMin = label.t % tenMinMs === 0;
                    const isMinute = label.t % oneMinMs === 0;
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    const tickHeight = Math.max(4, Math.round((isHalfHour ? 14 : isTenMin ? 11 : 7) * scale));
                    const alignedX = Math.round(label.x) + 0.5;
                    const tickTop = Math.round(tickBaseY) + 0.5;
                    const tickBottom = Math.round(tickBaseY + tickHeight) + 0.5;
                    ctx.strokeStyle = isHalfHour ? 'rgba(192, 192, 240, 0.65)' : isTenMin ? 'rgba(192, 192, 240, 0.45)' : isMinute ? 'rgba(192, 192, 240, 0.3)' : 'rgba(192, 192, 240, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickTop);
                    ctx.lineTo(alignedX, tickBottom);
                    ctx.stroke();
                    ctx.fillText(formatClockTime(label.t), Math.round(label.x), tickBaseY + 18);
                }
                const minorStart = Math.floor(start / oneMinMs) * oneMinMs;
                const minorEnd = Math.ceil(viewEnd / oneMinMs) * oneMinMs;
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(192, 192, 240, 0.3)';
                for (let t = minorStart; t <= minorEnd; t += oneMinMs) {
                    if (t % tenMinMs === 0) continue;
                    const x = pad.left + ((t - start) / pollenWindowMs) * plotW;
                    if (x < pad.left - 1 || x > pad.left + plotW + 1) continue;
                    const alignedX = Math.round(x) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(alignedX, tickBaseY);
                    const scale = Math.max(0.5, Math.min(1, plotH / 140));
                    ctx.lineTo(alignedX, tickBaseY + Math.max(4, Math.round(7 * scale)));
                    ctx.stroke();
                }
            }
        }

        function onPollenWheel(event) {
            event.preventDefault();
            const usePan = event.shiftKey || (event.buttons & 1) || Math.abs(event.deltaX) > Math.abs(event.deltaY);
            if (usePan) {
                const delta = Math.abs(event.deltaX) > Math.abs(event.deltaY) ? event.deltaX : event.deltaY;
                const panMs = delta * (pollenWindowMs / 600);
                pollenViewOffsetMs = Math.max(0, Math.min(getPollenMaxOffset(Date.now()), pollenViewOffsetMs + panMs));
                pollenUserPanned = pollenViewOffsetMs > 0;
                scheduleChartRender();
                return;
            }
            const direction = event.deltaY > 0 ? -1 : 1;
            const currentIndex = getZoomIndex();
            const nextIndex = Math.max(0, Math.min(zoomSteps.length - 1, currentIndex + direction));
            pollenWindowMs = zoomSteps[nextIndex].ms;
            pollenViewOffsetMs = Math.max(0, Math.min(getPollenMaxOffset(Date.now()), pollenViewOffsetMs));
            updateZoomControl();
            scheduleChartRender();
        }

        function onPollenDragStart(event) {
            const target = event.currentTarget;
            if (!target) return;
            pollenDrag = { x: event.clientX, offset: pollenViewOffsetMs, canvas: target };
            target.setPointerCapture(event.pointerId);
            target.style.cursor = 'grabbing';
        }

        function onPollenDragMove(event) {
            if (!pollenDrag || !pollenDrag.canvas) return;
            const rect = pollenDrag.canvas.getBoundingClientRect();
            const plotW = rect.width;
            if (plotW <= 0) return;
            const deltaX = event.clientX - pollenDrag.x;
            const msPerPx = pollenWindowMs / plotW;
            const nextOffset = pollenDrag.offset + deltaX * msPerPx;
            pollenViewOffsetMs = Math.max(0, Math.min(getPollenMaxOffset(Date.now()), nextOffset));
            pollenUserPanned = pollenViewOffsetMs > 0;
            scheduleChartRender();
        }

        function onPollenDragEnd(event) {
            if (!pollenDrag || !pollenDrag.canvas) return;
            try {
                pollenDrag.canvas.releasePointerCapture(event.pointerId);
            } catch (err) {}
            pollenDrag.canvas.style.cursor = 'grab';
            pollenDrag = null;
        }

        function getPollenMaxOffset(now) {
            const earliest = pollenSeries.length ? pollenSeries[0].t : now;
            return Math.max(0, now - earliest - pollenWindowMs);
        }

        function reloadHistory() {
            const oldScript = document.getElementById('history-script');
            if (oldScript) oldScript.remove();
            const script = document.createElement('script');
            script.id = 'history-script';
            script.src = 'stat_monitor_history.js?t=' + Date.now();
            script.onload = applyHistoryFromFile;
            script.onerror = function() {};
            document.head.appendChild(script);
        }

        function applyHistoryFromFile() {
            if (typeof statHistory === 'undefined' || !statHistory) {
                scheduleHistoryRetry();
                return;
            }
            if (Array.isArray(statHistory.backpack) && statHistory.backpack.length) {
                pollenSeries.length = 0;
                for (const entry of statHistory.backpack) {
                    if (!Array.isArray(entry) || entry.length < 2) continue;
                    const t = Number(entry[0]);
                    const v = Number(entry[1]);
                    if (isNaN(t) || isNaN(v)) continue;
                    pollenSeries.push({ t, v: Math.max(0, Math.min(100, v)) });
                }
                pollenHistoryLoaded = true;
                drawPollenChart();
            } else {
                scheduleHistoryRetry();
            }

            if (Array.isArray(statHistory.honey) && statHistory.honey.length > 1) {
                for (const entry of statHistory.honey) {
                    if (!Array.isArray(entry) || entry.length < 2) continue;
                    const t = Number(entry[0]);
                    const v = Number(entry[1]);
                    if (isNaN(t) || isNaN(v)) continue;
                    honeySamples.push({ t, v });
                }
                honeySamples.sort((a, b) => a.t - b.t);
                honeyHistoryLoaded = true;
                rebuildHoneySeries();
                drawHoneyChart();
            }

            if (statHistory.buffs && typeof statHistory.buffs === 'object') {
                for (const name of ['whiteboost', 'redboost', 'blueboost', 'haste', 'focus', 'bombcombo', 'balloonaura', 'reindeerfetch', 'honeymark', 'pollenmark', 'festivemark', 'popstar', 'melody', 'bear', 'babylove', 'jbshare', 'guiding']) {
                    const series = statHistory.buffs[name];
                    if (!Array.isArray(series)) continue;
                    buffUptimeSamples[name].length = 0;
                    for (const entry of series) {
                        if (!Array.isArray(entry) || entry.length < 2) continue;
                        const t = Number(entry[0]);
                        const v = Number(entry[1]);
                        if (isNaN(t) || isNaN(v)) continue;
                        buffUptimeSamples[name].push({ t, v });
                    }
                    buffUptimeSamples[name].sort((a, b) => a.t - b.t);
                }
                drawBuffUptimeChart();
            }
        }

        function scheduleHistoryRetry() {
            if (historyRetryTimer) return;
            historyRetryTimer = setTimeout(() => {
                historyRetryTimer = null;
                reloadHistory();
            }, 1000);
        }

        function loadPollenSeries() {
            try {
                const raw = localStorage.getItem(pollenStorageKey);
                if (!raw) return;
                const data = JSON.parse(raw);
                if (!Array.isArray(data)) return;
                const cutoff = Date.now() - pollenWindowMaxMs;
                pollenSeries.length = 0;
                for (const entry of data) {
                    if (!entry || typeof entry.t !== 'number' || typeof entry.v !== 'number') continue;
                    if (entry.t < cutoff) continue;
                    pollenSeries.push({ t: entry.t, v: Math.max(0, Math.min(100, entry.v)) });
                }
            } catch (err) {}
        }

        function savePollenSeries(force) {
            const now = Date.now();
            if (!force && now - pollenLastSave < 2000) return;
            pollenLastSave = now;
            try {
                localStorage.setItem(pollenStorageKey, JSON.stringify(pollenSeries));
            } catch (err) {}
        }

        function onPollenMouseDown(event) {
            if (event.button !== 0) return;
            const target = event.currentTarget;
            if (!target) return;
            pollenDrag = { x: event.clientX, offset: pollenViewOffsetMs, canvas: target };
            target.style.cursor = 'grabbing';
        }

        function onPollenMouseMove(event) {
            if (!pollenDrag || !pollenDrag.canvas || !(event.buttons & 1)) return;
            const rect = pollenDrag.canvas.getBoundingClientRect();
            const plotW = rect.width;
            if (plotW <= 0) return;
            const deltaX = event.clientX - pollenDrag.x;
            const msPerPx = pollenWindowMs / plotW;
            const nextOffset = pollenDrag.offset + deltaX * msPerPx;
            pollenViewOffsetMs = Math.max(0, Math.min(getPollenMaxOffset(Date.now()), nextOffset));
            pollenUserPanned = pollenViewOffsetMs > 0;
            scheduleChartRender();
        }

        function onPollenMouseUp() {
            pollenDrag = null;
            if (pollenCanvas) pollenCanvas.style.cursor = 'grab';
            if (honeyCanvas) honeyCanvas.style.cursor = 'grab';
        }

        function initChartControls() {
            const zoomRange = document.getElementById('zoom-range');
            if (!zoomRange) return;

            zoomRange.min = '0';
            zoomRange.max = String(zoomSteps.length - 1);
            zoomRange.step = '1';
            zoomRange.value = String(getZoomIndex());
            zoomRange.addEventListener('input', () => {
                const idx = Number(zoomRange.value);
                const next = zoomSteps[Math.max(0, Math.min(zoomSteps.length - 1, idx))];
                pollenWindowMs = next.ms;
                pollenViewOffsetMs = Math.max(0, Math.min(getPollenMaxOffset(Date.now()), pollenViewOffsetMs));
                updateZoomControl();
                scheduleChartRender();
            });

            renderZoomTicks();
            updateZoomControl();
        }

        function getZoomIndex() {
            let best = 0;
            let bestScore = Infinity;
            for (let i = 0; i < zoomSteps.length; i++) {
                const diff = Math.abs(pollenWindowMs - zoomSteps[i].ms);
                if (diff < bestScore) {
                    bestScore = diff;
                    best = i;
                }
            }
            return best;
        }

        function renderZoomTicks() {
            const zoomTicks = document.getElementById('zoom-ticks');
            if (!zoomTicks) return;
            zoomTicks.innerHTML = '';
            const tick = document.createElement('span');
            tick.classList.add('mid');
            zoomTicks.appendChild(tick);
        }

        function updateZoomControl() {
            const zoomRange = document.getElementById('zoom-range');
            if (!zoomRange) return;
            zoomRange.value = String(getZoomIndex());
        }

        function chooseTimeStep(windowMs) {
            const steps = [
                1000, 2000, 5000, 10000, 15000, 30000,
                60000, 120000, 300000, 600000, 900000, 1800000,
                3600000, 7200000
            ];
            const target = 6;
            let bestStep = steps[0];
            let bestScore = Infinity;
            for (const step of steps) {
                const count = windowMs / step;
                if (count < 2 || count > 18) continue;
                const score = Math.abs(count - target);
                if (score < bestScore) {
                    bestScore = score;
                    bestStep = step;
                }
            }
            return bestStep;
        }

        function formatClockTime(timeMs) {
            const date = new Date(timeMs);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        setInterval(reloadMessages, 1000);
        setInterval(reloadStats, 1000);
        window.addEventListener('resize', () => {
            scheduleChartResize();
        });
        ensurePollenCanvas();
        drawHoneyChart();
        drawPollenChart();
        drawBuffUptimeChart();
        scheduleChartResize();
        reloadMessages();
        reloadStats();
    </script>
</body>
</html>
